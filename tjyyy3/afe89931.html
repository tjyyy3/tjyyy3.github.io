<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0"><title>【作业】cv-cs131-hw6 | Growglow</title><meta name="author" content="jyyyy"><meta name="copyright" content="jyyyy"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="Homework 6 聚类算法0. Subtasks 聚类算法 K-Means Clustering  Hierarchical Agglomerative Clustering(HAC) 层次聚类   像素级别特征 implement 特征向量（包括颜色和位置信息） 完成特征的正则化   定量分析：与标准答案比较，分析分割算法的性能  1. 聚类算法1.1 K-Means Algorithm 普">
<meta property="og:type" content="article">
<meta property="og:title" content="【作业】cv-cs131-hw6">
<meta property="og:url" content="https://tjyyy3.github.io/tjyyy3/afe89931.html">
<meta property="og:site_name" content="Growglow">
<meta property="og:description" content="Homework 6 聚类算法0. Subtasks 聚类算法 K-Means Clustering  Hierarchical Agglomerative Clustering(HAC) 层次聚类   像素级别特征 implement 特征向量（包括颜色和位置信息） 完成特征的正则化   定量分析：与标准答案比较，分析分割算法的性能  1. 聚类算法1.1 K-Means Algorithm 普">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://tjyyy3.github.io/img/avatar.jpg">
<meta property="article:published_time" content="2024-05-25T15:25:01.000Z">
<meta property="article:modified_time" content="2024-08-27T03:37:15.193Z">
<meta property="article:author" content="jyyyy">
<meta property="article:tag" content="cv">
<meta property="article:tag" content="cs131">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://tjyyy3.github.io/img/avatar.jpg"><link rel="shortcut icon" href="/img/logo2.jpg"><link rel="canonical" href="https://tjyyy3.github.io/tjyyy3/afe89931.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  highlight: undefined,
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: true,
    post: false
  },
  runtime: '',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: true,
  }
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '【作业】cv-cs131-hw6',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2024-08-27 03:37:15'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
    win.getCSS = (url,id = false) => new Promise((resolve, reject) => {
      const link = document.createElement('link')
      link.rel = 'stylesheet'
      link.href = url
      if (id) link.id = id
      link.onerror = reject
      link.onload = link.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        link.onload = link.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(link)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><link rel="stylesheet" href="/css/universe.css?1"><link rel="stylesheet" href="/css/loading.css?1"><meta name="generator" content="Hexo 7.2.0"></head><body><div id="loading-box" onclick="document.getElementById(&quot;loading-box&quot;).classList.add(&quot;loaded&quot;)"><div class="loading-bg"><div class="loading-img"></div><div class="loading-image-dot"></div></div></div><script>const preloader = {
  endLoading: () => {
    document.body.style.overflow = 'auto';
    document.getElementById('loading-box').classList.add("loaded")
  },
  initLoading: () => {
    document.body.style.overflow = '';
    document.getElementById('loading-box').classList.remove("loaded")

  }
}
window.addEventListener('load',()=> { preloader.endLoading() })

if (true) {
  document.addEventListener('pjax:send', () => { preloader.initLoading() })
  document.addEventListener('pjax:complete', () => { preloader.endLoading() })
}</script><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/img/avatar.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">9</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">10</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">0</div></a></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header"><nav id="nav"><span id="blog-info"><a href="/" title="Growglow"><span class="site-name">Growglow</span></a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">【作业】cv-cs131-hw6</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2024-05-25T15:25:01.000Z" title="发表于 2024-05-25 15:25:01">2024-05-25</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2024-08-27T03:37:15.193Z" title="更新于 2024-08-27 03:37:15">2024-08-27</time></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">1.7k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>8分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="【作业】cv-cs131-hw6"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="Homework-6-聚类算法"><a href="#Homework-6-聚类算法" class="headerlink" title="Homework 6 聚类算法"></a>Homework 6 聚类算法</h1><h2 id="0-Subtasks"><a href="#0-Subtasks" class="headerlink" title="0. Subtasks"></a>0. Subtasks</h2><ol>
<li>聚类算法<ul>
<li>K-Means Clustering </li>
<li>Hierarchical Agglomerative Clustering(HAC) 层次聚类</li>
</ul>
</li>
<li>像素级别特征<ul>
<li>implement 特征向量（包括颜色和位置信息）</li>
<li>完成特征的正则化</li>
</ul>
</li>
<li>定量分析：与标准答案比较，分析分割算法的性能</li>
</ol>
<h2 id="1-聚类算法"><a href="#1-聚类算法" class="headerlink" title="1. 聚类算法"></a>1. 聚类算法</h2><h3 id="1-1-K-Means-Algorithm"><a href="#1-1-K-Means-Algorithm" class="headerlink" title="1.1 K-Means Algorithm"></a>1.1 K-Means Algorithm</h3><ol>
<li>普通做法</li>
</ol>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">kmeans</span>(<span class="params">features, k, num_iters=<span class="number">100</span></span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot; Use kmeans algorithm to group features into k clusters.K-Means algorithm can be broken down into following steps:</span></span><br><span class="line"><span class="string">    1. Randomly initialize cluster centers 随机初始化聚类的中心点</span></span><br><span class="line"><span class="string">    2. Assign each point to the closest center 把每个点都分给离它最近的点（形成聚类）</span></span><br><span class="line"><span class="string">    3. Compute new center of each cluster 计算每个聚类的新中心</span></span><br><span class="line"><span class="string">    4. Stop if cluster assignments did not change 如果中心点没有变说明聚类完成</span></span><br><span class="line"><span class="string">    5. Go to step 2</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">Args:</span></span><br><span class="line"><span class="string">    features - Array of N features vectors. Each row represents a feature</span></span><br><span class="line"><span class="string">        vector.</span></span><br><span class="line"><span class="string">    k - Number of clusters to form.</span></span><br><span class="line"><span class="string">    num_iters - Maximum number of iterations the algorithm will run.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">Returns:</span></span><br><span class="line"><span class="string">    assignments - Array representing cluster assignment of each point.</span></span><br><span class="line"><span class="string">        (e.g. i-th point is assigned to cluster assignments[i])</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">N, D = features.shape  <span class="comment"># N个点，每个点有D个特征</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">assert</span> N &gt;= k, <span class="string">&#x27;Number of clusters cannot be greater than number of points&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Randomly initalize cluster centers</span></span><br><span class="line">idxs = np.random.choice(N, size=k, replace=<span class="literal">False</span>)</span><br><span class="line">centers = features[idxs]</span><br><span class="line">assignments = np.zeros(N, dtype=np.uint32)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> n <span class="keyword">in</span> <span class="built_in">range</span>(num_iters):</span><br><span class="line">    <span class="comment">### YOUR CODE HERE</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(N):  <span class="comment"># 一共有N个点，都要计算一次距离</span></span><br><span class="line">        dist = np.linalg.norm(features[i]-centers, axis=<span class="number">1</span>)  <span class="comment"># 计算features[i]到每个中心点的距离</span></span><br><span class="line">        assignments[i]=np.argmin(dist)  <span class="comment"># 把第i个点分给离它最近的中心点</span></span><br><span class="line">    new_centers = np.array([features[assignments == j].mean(axis=<span class="number">0</span>) <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(k)])  <span class="comment"># 计算每个聚类的新中心点</span></span><br><span class="line">    <span class="keyword">if</span> np.array_equal(centers, new_centers):  <span class="comment"># 中止循环的条件</span></span><br><span class="line">       <span class="keyword">break</span></span><br><span class="line">    centers = new_centers  <span class="comment"># 更新中心点</span></span><br><span class="line">    <span class="comment">### END YOUR CODE</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> assignments</span><br></pre></td></tr></table></figure>
<p>​	运行结果：<img src="/../figs/1716625188357.png" alt="1716625188357"></p>
<ol start="2">
<li>加速kmeans</li>
</ol>
<p><code>kmeans_fast()</code>需要比<code>kmeans()</code>至少快10倍</p>
<pre><code>This function makes use of numpy functions and broadcasting to speed up the
first part(cluster assignment) of kmeans algorithm.

Hints
- You may find cdist (imported from scipy.spatial.distance) and np.argmin useful

Args:
    features - Array of N features vectors. Each row represents a feature
        vector.
    k - Number of clusters to form.
    num_iters - Maximum number of iterations the algorithm will run.

Returns:
    assignments - Array representing cluster assignment of each point.
        (e.g. i-th point is assigned to cluster assignments[i])
&quot;&quot;&quot;

N, D = features.shape

assert N &gt;= k, &#39;Number of clusters cannot be greater than number of points&#39;

# Randomly initalize cluster centers
idxs = np.random.choice(N, size=k, replace=False)
centers = features[idxs]
assignments = np.zeros(N, dtype=np.uint32)

for n in range(num_iters):
    ### YOUR CODE HERE
    pass
    ### END YOUR CODE

return assignments
</code></pre>
<p>​	运行结果：<img src="/../figs/1716625209560.png" alt="1716625209560"></p>
<p>（每次运行的时间都不一样，具有一定随机性，但是总体上都是比之前的<code>kmeans()</code>快10+）</p>
<h3 id="1-2-K-Means-Convergence"><a href="#1-2-K-Means-Convergence" class="headerlink" title="(1.2) K-Means Convergence"></a>(1.2) K-Means Convergence</h3><p><img src="/../figs/1716626222600.png" alt="1716626222600"></p>
<p>Q：为什么对于任何点集D和任意k个聚类，K-Means算法最会都能中止呢？</p>
<ul>
<li>K-Means算法在每次迭代中都会使代价函数 𝐿 非负且单调递减。</li>
<li>代价函数 𝐿 是有限的。</li>
<li>对于有限的点集 𝐷 和聚类数 𝑘，存在有限的可能聚类分配。</li>
<li>因此，K-Means算法在有限次迭代内必定会收敛并终止。</li>
</ul>
<h3 id="1-2-Hierarchical-Agglomerative-Clustering"><a href="#1-2-Hierarchical-Agglomerative-Clustering" class="headerlink" title="1.2 Hierarchical Agglomerative Clustering"></a>1.2 Hierarchical Agglomerative Clustering</h3><ol>
<li><p>算法解释：</p>
<ol>
<li>将每个点作为一个cluster</li>
<li>计算所有cluster的距离，合并两个最近的</li>
<li>直到最后剩下所期望的clusters</li>
</ol>
</li>
<li><p>需要用到的函数解释：</p>
<ul>
<li><p><code>squareform</code>: 向量形式距离向量转换为矩形形式距离矩阵,反之亦然。</p>
</li>
<li><p><code>pdist(X, metric=&#39;euclidean&#39;, *args, **kwargs)</code>: Pairwise distances between observations in n-dimensional space. </p>
<ul>
<li><strong>X</strong>: 一个形状为 (M, N) 的二维数组，表示 M 个点的 N 维坐标。</li>
<li><strong>metric</strong>: 用于计算距离的度量标准。默认是欧氏距离 (‘euclidean’)。常用的度量标准还包括 ‘cityblock’ (曼哈顿距离), ‘cosine’ (余弦距离) 等。</li>
<li>返回一个压缩的距离矩阵，形状为 (M*(M-1)&#x2F;2, )，包含所有点对之间的距离。</li>
</ul>
</li>
</ul>
<p> def hierarchical_clustering(features, k):<br>     “”” Run the hierarchical agglomerative clustering algorithm.The algorithm is conceptually simple:</p>
<pre><code> Assign each point to its own cluster
 While the number of clusters is greater than k:
     Compute the distance between all pairs of clusters
     Merge the pair of clusters that are closest to each other

 We will use Euclidean distance to define distance between clusters.

 Recomputing the centroids of all clusters and the distances between all
 pairs of centroids at each step of the loop would be very slow. Thankfully
 most of the distances and centroids remain the same in successive
 iterations of the outer loop; therefore we can speed up the computation by
 only recomputing the centroid and distances for the new merged cluster.

 Even with this trick, this algorithm will consume a lot of memory and run
 very slowly when clustering large set of points. In practice, you probably
 do not want to use this algorithm to cluster more than 10,000 points.

 Hints
 - You may find pdist (imported from scipy.spatial.distance) useful

 Args:
     features - Array of N features vectors. Each row represents a feature
         vector.
     k - Number of clusters to form.

 Returns:
     assignments - Array representing cluster assignment of each point.
         (e.g. i-th point is assigned to cluster assignments[i])
</code></pre>
<p> “””<br> N, D &#x3D; features.shape</p>
<p> assert N &gt;&#x3D; k, ‘Number of clusters cannot be greater than number of points’</p>
<h1 id="Assign-each-point-to-its-own-cluster"><a href="#Assign-each-point-to-its-own-cluster" class="headerlink" title="Assign each point to its own cluster"></a>Assign each point to its own cluster</h1><p> assignments &#x3D; np.arange(N, dtype&#x3D;np.uint32)<br> centers &#x3D; np.copy(features)<br> n_clusters &#x3D; N<br> while n_clusters &gt; k:<br>     ### YOUR CODE HERE<br>     dist_matrix &#x3D; squareform(pdist(centers, metric&#x3D;’euclidean’))<br>     np.fill_diagonal(dist_matrix, np.inf)<br>     minDist &#x3D; np.argmin(dist_matrix)<br>     min_i &#x3D; minDist &#x2F;&#x2F; n_clusters<br>     min_j &#x3D; minDist - min_i * n_clusters</p>
<pre><code> if min_j &lt; min_i:
     min_i, min_j = min_j, min_i  # 对称的，所以可以交换
 
 for i in range(N):
     if assignments[i] == min_j:
         assignments[i] = min_i
     elif assignments[i] &gt; min_j:
         assignments[i] -= 1
 
 centers = np.delete(centers, min_j, axis=0)
 centers[min_i] = np.mean(features[assignments == min_i], axis=0)
 n_clusters -= 1
 ### END YOUR CODE
</code></pre>
<p> return assignments</p>
</li>
</ol>
<h2 id="2-Pixel-Level-Features"><a href="#2-Pixel-Level-Features" class="headerlink" title="2. Pixel-Level Features"></a>2. Pixel-Level Features</h2><h3 id="2-1-提取颜色特征"><a href="#2-1-提取颜色特征" class="headerlink" title="2.1 提取颜色特征"></a>2.1 提取颜色特征</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">color_features</span>(<span class="params">img</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot; Represents a pixel by its color.</span></span><br><span class="line"><span class="string">    Args:</span></span><br><span class="line"><span class="string">    	img - array of shape (H, W, C)</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    Returns:</span></span><br><span class="line"><span class="string">        features - array of (H * W, C)</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line">    H, W, C = img.shape</span><br><span class="line">    img = img_as_float(img)</span><br><span class="line">    features = np.zeros((H*W, C))</span><br><span class="line"></span><br><span class="line">    <span class="comment">### YOUR CODE HERE</span></span><br><span class="line">    features = img.reshape(-<span class="number">1</span>, C)</span><br><span class="line">    <span class="comment">### END YOUR CODE</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> features</span><br></pre></td></tr></table></figure>
<h3 id="2-2-颜色和位置特征"><a href="#2-2-颜色和位置特征" class="headerlink" title="2.2 颜色和位置特征"></a>2.2 颜色和位置特征</h3><ol>
<li>需要用到的函数解释：<ul>
<li><code>np.mgrid[start:end:step]</code>： 构建多维数组（不是很懂呢。。）</li>
<li><code>np.dstack()</code>：将列表中的数组沿深度方向进行拼接。当数组为2维数组<code>(M,N)</code>或1维数组<code>(N,)</code>时，首先分别将其维度改变为<code>(M,N,1)</code>、<code>(1,N,1)</code>，然后沿着第三根轴进行拼接。使用函数<code>dsplit</code>可以将数组沿深度方向进行分隔。</li>
</ul>
</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">def color_position_features(img):</span><br><span class="line">    &quot;&quot;&quot; Represents a pixel by its color and position.</span><br><span class="line"></span><br><span class="line">    Combine pixel&#x27;s RGB value and xy coordinates into a feature vector.</span><br><span class="line">    i.e. for a pixel of color (r, g, b) located at position (x, y) in the</span><br><span class="line">    image. its feature vector would be (r, g, b, x, y).</span><br><span class="line"></span><br><span class="line">    Don&#x27;t forget to normalize features.</span><br><span class="line"></span><br><span class="line">    Hints</span><br><span class="line">    - You may find np.mgrid and np.dstack useful</span><br><span class="line">    - You may use np.mean and np.std</span><br><span class="line"></span><br><span class="line">    Args:</span><br><span class="line">        img - array of shape (H, W, C)</span><br><span class="line"></span><br><span class="line">    Returns:</span><br><span class="line">        features - array of (H * W, C+2)</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    H, W, C = img.shape</span><br><span class="line">    color = img_as_float(img)</span><br><span class="line">    features = np.zeros((H*W, C+2))</span><br><span class="line"></span><br><span class="line">    ### YOUR CODE HERE</span><br><span class="line">    x, y = np.mgrid[0:H, 0:W]  # np.mgrid 生成一个网格，其中 x 包含每个像素的 x 坐标，y 包含每个像素的 y 坐标。</span><br><span class="line">    # x / H 和 y / W 用来将位置坐标归一化到 [0, 1] 范围</span><br><span class="line">    # reshape(-1, C + 2) 将堆叠后的结果展平为 (H * W, C + 2) 的二维数组</span><br><span class="line">    features = np.dstack((color, x/H, y/W)).reshape(-1, C+2)</span><br><span class="line">    features_mean = np.mean(features, axis=0)</span><br><span class="line">    features_std = np.std(features, axis=0)</span><br><span class="line">    features = (features - features_mean)/features_std</span><br><span class="line">    ### END YOUR CODE</span><br><span class="line"></span><br><span class="line">    return features</span><br></pre></td></tr></table></figure>

</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="https://tjyyy3.github.io">jyyyy</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://tjyyy3.github.io/tjyyy3/afe89931.html">https://tjyyy3.github.io/tjyyy3/afe89931.html</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://tjyyy3.github.io" target="_blank">Growglow</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/cv/">cv</a><a class="post-meta__tags" href="/tags/cs131/">cs131</a></div><div class="post_share"><div class="social-share" data-image="/img/avatar.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/tjyyy3/82cd03f6.html" title="【分享】c++如何读入文件内的数据"><div class="cover" style="background: var(--default-bg-color)"></div><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">【分享】c++如何读入文件内的数据</div></div></a></div><div class="next-post pull-right"><a href="/tjyyy3/9fbdf394.html" title="【嵌入式】基于stm32的语音控制四组机器人——准备材料篇"><div class="cover" style="background: var(--default-bg-color)"></div><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">【嵌入式】基于stm32的语音控制四组机器人——准备材料篇</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/tjyyy3/fb16db7d.html" title="【作业】cv-cs131-hw2[ing]"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2024-05-17</div><div class="title">【作业】cv-cs131-hw2[ing]</div></div></a></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="/img/avatar.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">jyyyy</div><div class="author-info__description">活几个瞬间</div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">9</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">10</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">0</div></a></div><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/tjyyy3" target="_blank" title="Github"><i class="fab fa-github"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">Welcom to my blog! Have a good time~</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#Homework-6-%E8%81%9A%E7%B1%BB%E7%AE%97%E6%B3%95"><span class="toc-number">1.</span> <span class="toc-text">Homework 6 聚类算法</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#0-Subtasks"><span class="toc-number">1.1.</span> <span class="toc-text">0. Subtasks</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-%E8%81%9A%E7%B1%BB%E7%AE%97%E6%B3%95"><span class="toc-number">1.2.</span> <span class="toc-text">1. 聚类算法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-1-K-Means-Algorithm"><span class="toc-number">1.2.1.</span> <span class="toc-text">1.1 K-Means Algorithm</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-2-K-Means-Convergence"><span class="toc-number">1.2.2.</span> <span class="toc-text">(1.2) K-Means Convergence</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-2-Hierarchical-Agglomerative-Clustering"><span class="toc-number">1.2.3.</span> <span class="toc-text">1.2 Hierarchical Agglomerative Clustering</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Assign-each-point-to-its-own-cluster"><span class="toc-number">2.</span> <span class="toc-text">Assign each point to its own cluster</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#2-Pixel-Level-Features"><span class="toc-number">2.1.</span> <span class="toc-text">2. Pixel-Level Features</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-1-%E6%8F%90%E5%8F%96%E9%A2%9C%E8%89%B2%E7%89%B9%E5%BE%81"><span class="toc-number">2.1.1.</span> <span class="toc-text">2.1 提取颜色特征</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-2-%E9%A2%9C%E8%89%B2%E5%92%8C%E4%BD%8D%E7%BD%AE%E7%89%B9%E5%BE%81"><span class="toc-number">2.1.2.</span> <span class="toc-text">2.2 颜色和位置特征</span></a></li></ol></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/tjyyy3/4a17b156.html" title="Hello World">Hello World</a><time datetime="2024-08-27T03:37:15.193Z" title="发表于 2024-08-27 03:37:15">2024-08-27</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/tjyyy3/5806835b.html" title="【题解】3151.特殊数组I、II">【题解】3151.特殊数组I、II</a><time datetime="2024-08-14T08:43:01.000Z" title="发表于 2024-08-14 08:43:01">2024-08-14</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/tjyyy3/847fdde3.html" title="【嵌入式】基于stm32的语音控制四组机器人——制作篇">【嵌入式】基于stm32的语音控制四组机器人——制作篇</a><time datetime="2024-08-13T23:31:13.000Z" title="发表于 2024-08-13 23:31:13">2024-08-13</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/tjyyy3/9fbdf394.html" title="【嵌入式】基于stm32的语音控制四组机器人——准备材料篇">【嵌入式】基于stm32的语音控制四组机器人——准备材料篇</a><time datetime="2024-06-03T23:31:01.000Z" title="发表于 2024-06-03 23:31:01">2024-06-03</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/tjyyy3/afe89931.html" title="【作业】cv-cs131-hw6">【作业】cv-cs131-hw6</a><time datetime="2024-05-25T15:25:01.000Z" title="发表于 2024-05-25 15:25:01">2024-05-25</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2024 By jyyyy</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.umd.min.js"></script><div class="js-pjax"></div><script defer src="https://npm.elemecdn.com/jquery@latest/dist/jquery.min.js"></script><canvas id="universe"></canvas><script defer src="/js/universe.js?1"></script><script src="https://cdn.jsdelivr.net/npm/pjax/pjax.min.js"></script><script>let pjaxSelectors = ["head > title","#config-diff","#body-wrap","#rightside-config-hide","#rightside-config-show",".js-pjax"]

var pjax = new Pjax({
  elements: 'a:not([target="_blank"])',
  selectors: pjaxSelectors,
  cacheBust: false,
  analytics: false,
  scrollRestoration: false
})

document.addEventListener('pjax:send', function () {

  // removeEventListener scroll 
  window.tocScrollFn && window.removeEventListener('scroll', window.tocScrollFn)
  window.scrollCollect && window.removeEventListener('scroll', scrollCollect)

  document.getElementById('rightside').style.cssText = "opacity: ''; transform: ''"
  
  if (window.aplayers) {
    for (let i = 0; i < window.aplayers.length; i++) {
      if (!window.aplayers[i].options.fixed) {
        window.aplayers[i].destroy()
      }
    }
  }

  typeof typed === 'object' && typed.destroy()

  //reset readmode
  const $bodyClassList = document.body.classList
  $bodyClassList.contains('read-mode') && $bodyClassList.remove('read-mode')

  typeof disqusjs === 'object' && disqusjs.destroy()
})

document.addEventListener('pjax:complete', function () {
  window.refreshFn()

  document.querySelectorAll('script[data-pjax]').forEach(item => {
    const newScript = document.createElement('script')
    const content = item.text || item.textContent || item.innerHTML || ""
    Array.from(item.attributes).forEach(attr => newScript.setAttribute(attr.name, attr.value))
    newScript.appendChild(document.createTextNode(content))
    item.parentNode.replaceChild(newScript, item)
  })

  GLOBAL_CONFIG.islazyload && window.lazyLoadInstance.update()

  typeof chatBtnFn === 'function' && chatBtnFn()
  typeof panguInit === 'function' && panguInit()

  // google analytics
  typeof gtag === 'function' && gtag('config', '', {'page_path': window.location.pathname});

  // baidu analytics
  typeof _hmt === 'object' && _hmt.push(['_trackPageview',window.location.pathname]);

  typeof loadMeting === 'function' && document.getElementsByClassName('aplayer').length && loadMeting()

  // prismjs
  typeof Prism === 'object' && Prism.highlightAll()
})

document.addEventListener('pjax:error', (e) => {
  if (e.request.status === 404) {
    pjax.loadUrl('/404.html')
  }
})</script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>